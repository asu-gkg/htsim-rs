<!doctype html>
<html lang="zh">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>htsim-rs 可视化回放</title>
    <style>
      :root {
        --bg: #0b1020;
        --panel: #121a33;
        --text: #e7ecff;
        --muted: #aab3d6;
        --accent: #7aa2ff;
        --danger: #ff6b6b;
        --ok: #64d49a;
      }
      body {
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial,
          "Apple Color Emoji", "Segoe UI Emoji";
        background: var(--bg);
        color: var(--text);
      }
      .wrap {
        display: grid;
        grid-template-columns: 360px 1fr;
        min-height: 100vh;
      }
      .left {
        background: var(--panel);
        padding: 14px 14px 10px;
        border-right: 1px solid rgba(255, 255, 255, 0.08);
      }
      .right {
        padding: 14px;
      }
      h1 {
        font-size: 16px;
        margin: 0 0 12px;
        letter-spacing: 0.2px;
      }
      .row {
        display: grid;
        gap: 8px;
        margin-bottom: 10px;
      }
      label {
        font-size: 12px;
        color: var(--muted);
      }
      input[type="file"],
      input[type="text"],
      select,
      button {
        width: 100%;
        box-sizing: border-box;
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid rgba(255, 255, 255, 0.10);
        color: var(--text);
        border-radius: 10px;
        padding: 10px 10px;
        outline: none;
      }
      button {
        cursor: pointer;
        background: rgba(122, 162, 255, 0.16);
        border-color: rgba(122, 162, 255, 0.32);
      }
      button.secondary {
        background: rgba(255, 255, 255, 0.06);
        border-color: rgba(255, 255, 255, 0.10);
      }
      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .btns {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 8px;
      }
      .timeline {
        display: grid;
        grid-template-columns: 1fr;
        gap: 6px;
        margin-top: 8px;
      }
      input[type="range"] {
        width: 100%;
      }
      .small {
        font-size: 12px;
        color: var(--muted);
        line-height: 1.4;
      }
      .kbd {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 11px;
        padding: 2px 6px;
        border: 1px solid rgba(255,255,255,0.12);
        border-radius: 6px;
        background: rgba(0,0,0,0.25);
        color: var(--text);
      }
      .log {
        margin-top: 12px;
        padding: 10px;
        background: rgba(0, 0, 0, 0.25);
        border: 1px solid rgba(255,255,255,0.10);
        border-radius: 12px;
        height: 40vh;
        overflow: auto;
        white-space: pre-wrap;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 11px;
        color: #cdd6ff;
      }
      canvas {
        width: 100%;
        max-width: 1100px;
        height: 360px;
        border-radius: 14px;
        border: 1px solid rgba(255,255,255,0.10);
        background: linear-gradient(180deg, rgba(255,255,255,0.05), rgba(0,0,0,0.08));
        display: block;
      }
      .hint {
        margin-top: 10px;
        color: var(--muted);
        font-size: 12px;
      }
      .pill {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 999px;
        border: 1px solid rgba(255,255,255,0.12);
        background: rgba(255,255,255,0.06);
        margin-right: 6px;
        font-size: 12px;
        color: var(--muted);
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="left">
        <h1>htsim-rs 回放器（离线 HTML）</h1>

        <div class="row">
          <label>1) 选择 JSON 事件文件（由 dumbbell_tcp 生成）</label>
          <input id="file" type="file" accept=".json,application/json" />
          <div class="small">
            生成命令示例：<span class="kbd">cargo run --bin dumbbell_tcp -- --viz-json out.json ...</span>
          </div>
        </div>

        <div class="row">
          <label>2) 过滤（可选）</label>
          <input id="filterFlow" type="text" placeholder="flow_id (例如 1)" />
          <input id="filterPkt" type="text" placeholder="pkt_id (例如 42)" />
        </div>

        <div class="row">
          <label>2.5) CWND 连接</label>
          <select id="connPick" disabled></select>
          <div class="small">自动：优先 flow_id 过滤，否则选第一个连接。</div>
        </div>

        <div class="row">
          <label>3) 控制</label>
          <div class="btns">
            <button id="play" disabled>播放</button>
            <button id="pause" class="secondary" disabled>暂停</button>
            <button id="step" class="secondary" disabled>单步</button>
          </div>
        </div>

        <div class="row">
          <button id="jumpDrop" class="secondary" disabled>跳到下一次丢包</button>
          <div class="small">从当前时间往后查找下一条 drop 事件（可配合 flow_id 过滤）。</div>
        </div>

        <div class="row">
          <label>速度</label>
          <select id="speed" disabled>
            <option value="0.25">0.25x</option>
            <option value="0.5">0.5x</option>
            <option value="1" selected>1x</option>
            <option value="2">2x</option>
            <option value="5">5x</option>
            <option value="10">10x</option>
          </select>
        </div>

        <div class="row">
          <label>回放时长（秒，1x 时播完整段仿真）</label>
          <select id="targetWallSec" disabled>
            <option value="3">3s</option>
            <option value="6">6s</option>
            <option value="12" selected>12s</option>
            <option value="20">20s</option>
            <option value="40">40s</option>
          </select>
          <div class="small">避免“仿真只有几十毫秒，播放一两帧就到结尾”的问题。</div>
        </div>

        <div class="row">
          <label>节点 / 链路状态（随时间更新）</label>
          <div id="stats" class="log">（空）</div>
        </div>

        <div class="timeline">
          <label>时间轴</label>
          <input id="slider" type="range" min="0" max="1000" value="0" disabled />
          <div class="small">
            <span class="pill">空格</span>播放/暂停
            <span class="pill">←/→</span>单步
          </div>
          <div id="status" class="small">未加载</div>
        </div>

        <div class="row">
          <label>当前事件（按时间推进）</label>
          <div id="cur" class="log">（空）</div>
        </div>
      </div>

      <div class="right">
        <canvas id="cv" width="1100" height="360"></canvas>
        <div style="height: 12px"></div>
        <canvas id="tcpCv" width="1100" height="240"></canvas>
        <div class="hint">
          说明：蓝色圆点=Data，绿色圆点=ACK，红色 X=Drop。链路上的圆点会按 <span class="kbd">tx_start.depart_ns → arrive_ns</span>
          做线性动画。节点高亮表示 <span class="kbd">node_rx</span>。
        </div>
      </div>
    </div>

    <script>
      /** @typedef {{t_ns:number, pkt_id?:number|null, flow_id?:number|null, pkt_bytes?:number|null, pkt_kind?:string|null, kind:string}} VizEvent */

      const $ = (id) => document.getElementById(id);
      const fileEl = $("file");
      const playEl = $("play");
      const pauseEl = $("pause");
      const stepEl = $("step");
      const speedEl = $("speed");
      const targetWallSecEl = $("targetWallSec");
      const sliderEl = $("slider");
      const statusEl = $("status");
      const curEl = $("cur");
      const statsEl = $("stats");
      const jumpDropEl = $("jumpDrop");
      const filterFlowEl = $("filterFlow");
      const filterPktEl = $("filterPkt");
      const connPickEl = $("connPick");
      const cv = $("cv");
      const ctx = cv.getContext("2d");
      const tcpCv = $("tcpCv");
      const tcpCtx = tcpCv.getContext("2d");

      /** @type {VizEvent[]} */
      let events = [];
      /** @type {VizEvent[]} */
      let filtered = [];
      let t0 = 0;
      let t1 = 0;
      let curTime = 0;
      let cursor = 0; // next event index
      let playing = false;
      let lastWall = 0;

      // state for animation
      /** @type {Map<number, any>} */
      let inflight = new Map(); // pkt_id -> {from,to,depart,arrive,kind,flow_id}
      /** @type {Map<number, {node:number, until:number}>} */
      let nodeHighlight = new Map(); // node -> until(t_ns)
      /** @type {Array<{pkt_id:number, flow_id:number|null, from:number, to:number, at:number, until:number}>} */
      let dropMarks = [];
      /** @type {string[]} */
      let lastEventsText = [];

      // meta（来自 kind=meta）
      /** @type {{nodes?: any[], links?: any[]}|null} */
      let meta = null;
      /** @type {any[]} */
      const defaultNodes = [
        { id: 0, name: "h0", kind: "host", x: 120, y: 180 },
        { id: 2, name: "s0", kind: "switch", x: 380, y: 180 },
        { id: 3, name: "s1", kind: "switch", x: 720, y: 180 },
        { id: 1, name: "h1", kind: "host", x: 980, y: 180 },
      ];
      let nodes = defaultNodes.map((n) => ({ ...n }));
      let nodeById = new Map(nodes.map((n) => [n.id, n]));
      const defaultLinks = [
        { from: 0, to: 2 },
        { from: 2, to: 3 },
        { from: 3, to: 1 },
      ];
      let drawLinks = defaultLinks.slice();
      let nodeScale = 1;

      // 统计状态（由事件增量更新）
      /** @type {Map<number, any>} */
      let nodeStats = new Map(); // id -> counters
      /** @type {Map<string, any>} */
      let linkStats = new Map(); // "from->to" -> {q_bytes,q_cap,tx_pkts,drop_pkts,bandwidth_bps,latency_ns}
      /** @type {{send_data:number, send_ack:number, recv_ack:number, rto:number}} */
      let tcpStats = { send_data: 0, send_ack: 0, recv_ack: 0, rto: 0 };

      // cwnd 时序（优先使用 dctcp_cwnd 采样；否则从 tcp_* 事件推演）
      /** @type {Map<number, {mss:number, points:Array<any>}>} */
      let tcpSeries = new Map();

      function linkKey(a, b) {
        return `${a}->${b}`;
      }

      function fmtMs(ns) {
        return (ns / 1e6).toFixed(3) + " ms";
      }

      function fmtGbps(bps) {
        if (bps == null) return "-";
        return (Number(bps) / 1e9).toFixed(3) + " Gbps";
      }

      function fmtBytes(x) {
        if (x == null) return "-";
        const n = Number(x);
        if (n < 1024) return `${n} B`;
        if (n < 1024 * 1024) return `${(n / 1024).toFixed(2)} KiB`;
        if (n < 1024 * 1024 * 1024) return `${(n / 1024 / 1024).toFixed(2)} MiB`;
        return `${(n / 1024 / 1024 / 1024).toFixed(2)} GiB`;
      }

      function fmtCapBytes(x) {
        // Rust 里默认 DropTailQueue 是 u64::MAX（几乎无限），直接显示会很难读
        if (x == null) return "-";
        const n = Number(x);
        if (n === 18446744073709551615) return "∞";
        return fmtBytes(n);
      }

      function buildLinkPairs(links) {
        if (!links || !Array.isArray(links)) return [];
        const out = [];
        const seen = new Set();
        for (const l of links) {
          const a = Number(l.from);
          const b = Number(l.to);
          if (!Number.isFinite(a) || !Number.isFinite(b)) continue;
          const key = a < b ? `${a}-${b}` : `${b}-${a}`;
          if (seen.has(key)) continue;
          seen.add(key);
          out.push({ from: a, to: b });
        }
        return out;
      }

      function parseFatTreeName(name) {
        if (!name) return null;
        let m = /^c(\d+)_(\d+)$/.exec(name);
        if (m) return { kind: "core", group: Number(m[1]), index: Number(m[2]) };
        m = /^p(\d+)_a(\d+)$/.exec(name);
        if (m) return { kind: "agg", pod: Number(m[1]), index: Number(m[2]) };
        m = /^p(\d+)_e(\d+)$/.exec(name);
        if (m) return { kind: "edge", pod: Number(m[1]), index: Number(m[2]) };
        m = /^h(\d+)_(\d+)_(\d+)$/.exec(name);
        if (m) return { kind: "host", pod: Number(m[1]), edge: Number(m[2]), index: Number(m[3]) };
        return null;
      }

      function layoutFatTree(list) {
        const parsed = list.map((it) => ({ it, info: parseFatTreeName(it.name ?? "") }));
        if (parsed.some((p) => !p.info)) return null;
        let maxPod = -1;
        let maxAgg = -1;
        let maxEdge = -1;
        let maxCoreGroup = -1;
        let maxCoreIndex = -1;
        let maxHost = -1;
        for (const p of parsed) {
          const info = p.info;
          if (info.kind === "core") {
            maxCoreGroup = Math.max(maxCoreGroup, info.group);
            maxCoreIndex = Math.max(maxCoreIndex, info.index);
          } else if (info.kind === "agg") {
            maxPod = Math.max(maxPod, info.pod);
            maxAgg = Math.max(maxAgg, info.index);
          } else if (info.kind === "edge") {
            maxPod = Math.max(maxPod, info.pod);
            maxEdge = Math.max(maxEdge, info.index);
          } else if (info.kind === "host") {
            maxPod = Math.max(maxPod, info.pod);
            maxEdge = Math.max(maxEdge, info.edge);
            maxHost = Math.max(maxHost, info.index);
          }
        }
        const k = maxPod + 1;
        const half = Math.max(maxAgg, maxEdge, maxCoreGroup, maxCoreIndex, maxHost) + 1;
        if (k <= 0 || half <= 0) return null;

        const width = cv.width;
        const height = cv.height;
        const left = 50;
        const right = 50;
        const top = 36;
        const bottom = 36;
        const spanH = Math.max(1, height - top - bottom);
        const rowGap = spanH / 3;
        const rowY = {
          core: top,
          agg: top + rowGap,
          edge: top + rowGap * 2,
          host: top + rowGap * 3,
        };
        const podWidth = (width - left - right) / Math.max(1, k);
        const coreGroupWidth = (width - left - right) / Math.max(1, half);

        function xForCore(group, index) {
          const groupLeft = left + coreGroupWidth * group;
          return groupLeft + coreGroupWidth * (index + 0.5) / Math.max(1, half);
        }

        function xForPod(pod, index) {
          const podLeft = left + podWidth * pod;
          return podLeft + podWidth * (index + 0.5) / Math.max(1, half);
        }

        function xForHost(pod, edge, host) {
          const podLeft = left + podWidth * pod;
          const edgeSpan = podWidth / Math.max(1, half);
          const hostSpan = edgeSpan / Math.max(1, half);
          return podLeft + edgeSpan * edge + hostSpan * (host + 0.5);
        }

        const nodes = parsed.map(({ it, info }) => {
          let x = width / 2;
          let y = height / 2;
          if (info.kind === "core") {
            x = xForCore(info.group, info.index);
            y = rowY.core;
          } else if (info.kind === "agg") {
            x = xForPod(info.pod, info.index);
            y = rowY.agg;
          } else if (info.kind === "edge") {
            x = xForPod(info.pod, info.index);
            y = rowY.edge;
          } else if (info.kind === "host") {
            x = xForHost(info.pod, info.edge, info.index);
            y = rowY.host;
          }
          return {
            id: it.id,
            name: it.name ?? `n${it.id}`,
            kind: it.kind ?? "switch",
            x,
            y,
          };
        });
        const scale = Math.max(0.5, Math.min(1, 12 / Math.sqrt(Math.max(1, nodes.length))));
        return { nodes, scale };
      }

      function layoutCircle(list) {
        const width = cv.width;
        const height = cv.height;
        const cx = width / 2;
        const cy = height / 2;
        const r = Math.min(width, height) * 0.35;
        const n = Math.max(1, list.length);
        const nodes = list.map((it, i) => {
          const ang = (Math.PI * 2 * i) / n - Math.PI / 2;
          return {
            id: it.id,
            name: it.name ?? `n${it.id}`,
            kind: it.kind ?? "switch",
            x: cx + r * Math.cos(ang),
            y: cy + r * Math.sin(ang),
          };
        });
        const scale = Math.max(0.5, Math.min(1, 16 / Math.sqrt(n)));
        return { nodes, scale };
      }

      function setEnabled(ok) {
        playEl.disabled = !ok;
        pauseEl.disabled = !ok;
        stepEl.disabled = !ok;
        speedEl.disabled = !ok;
        targetWallSecEl.disabled = !ok;
        sliderEl.disabled = !ok;
        jumpDropEl.disabled = !ok;
        connPickEl.disabled = !ok;
      }

      function updateConnPick() {
        const conns = Array.from(tcpSeries.keys()).sort((a, b) => a - b);
        const prev = connPickEl.value || "auto";
        connPickEl.innerHTML = "";
        connPickEl.appendChild(new Option("auto", "auto"));
        for (const cid of conns) {
          connPickEl.appendChild(new Option(String(cid), String(cid)));
        }
        if (prev !== "auto" && conns.includes(Number(prev))) {
          connPickEl.value = prev;
        } else {
          connPickEl.value = "auto";
        }
        connPickEl.disabled = conns.length === 0;
      }

      function applyFilter() {
        const flow = filterFlowEl.value.trim();
        const pkt = filterPktEl.value.trim();
        const flowN = flow === "" ? null : Number(flow);
        const pktN = pkt === "" ? null : Number(pkt);
        filtered = events.filter((e) => {
          if (flowN != null) {
            if (e.flow_id == null || Number(e.flow_id) !== flowN) return false;
          }
          if (pktN != null) {
            if (e.pkt_id == null || Number(e.pkt_id) !== pktN) return false;
          }
          return true;
        });
        // reset playback state
        resetPlayback();
      }

      function resetPlayback() {
        inflight = new Map();
        nodeHighlight = new Map();
        dropMarks = [];
        lastEventsText = [];
        nodeStats = new Map();
        linkStats = new Map();
        tcpStats = { send_data: 0, send_ack: 0, recv_ack: 0, rto: 0 };
        tcpSeries = buildTcpSeries(events);
        updateConnPick();
        initStatsFromMeta();
        cursor = 0;
        curTime = t0;
        sliderEl.value = "0";
        updateStatus();
        redraw();
        showCurrentText();
        showStatsText();
        redrawTcp();
      }

      function initStatsFromMeta() {
        // nodes
        for (const n of nodes) {
          nodeStats.set(n.id, {
            rx: 0,
            forward: 0,
            delivered: 0,
            bytes: 0,
          });
        }
        // links
        if (meta?.links) {
          for (const l of meta.links) {
            linkStats.set(linkKey(l.from, l.to), {
              from: l.from,
              to: l.to,
              q_bytes: 0,
              q_peak: 0,
              q_cap: l.q_cap_bytes ?? null,
              tx_pkts: 0,
              drop_pkts: 0,
              first_drop_t: null,
              bandwidth_bps: l.bandwidth_bps ?? null,
              latency_ns: l.latency_ns ?? null,
            });
          }
        }
      }

      function updateStatus() {
        statusEl.textContent =
          filtered.length === 0
            ? `已加载 ${events.length} 条事件（过滤后 0）`
            : `已加载 ${events.length} 条事件（过滤后 ${filtered.length}），时间范围：${fmtMs(t0)} → ${fmtMs(t1)}，当前：${fmtMs(curTime)}`;
      }

      function showCurrentText() {
        curEl.textContent = lastEventsText.slice(-80).join("\n") || "（空）";
      }

      function showStatsText() {
        const lines = [];
        lines.push(`时间：${fmtMs(curTime)} / ${fmtMs(t1)}`);
        lines.push("说明：drop 发生在链路队列（link_from->link_to），不是 host。");
        lines.push("提示：最终 q=0 只代表仿真结束时队列已排空；请看 q_peak（峰值）或点“跳到首次丢包”。");
        lines.push("");
        lines.push("节点状态（计数随时间推进）：");
        lines.push("- rx：节点收到并开始处理（node_rx）");
        lines.push("- forward：节点决定下一跳（node_forward）");
        lines.push("- delivered：到达目的节点并交付（delivered）");
        lines.push("");
        for (const n of nodes) {
          const s = nodeStats.get(n.id) || {};
          lines.push(
            `- ${n.name}(${n.kind}) id=${n.id}: rx=${s.rx ?? 0}, forward=${s.forward ?? 0}, delivered=${s.delivered ?? 0}, rx_bytes=${fmtBytes(s.bytes ?? 0)}`
          );
        }
        lines.push("");
        lines.push("链路状态（队列/带宽/时延）：");
        lines.push("- q：队列字节数（enqueue/drop 事件里的 q_bytes）");
        lines.push("- q_peak：队列峰值（整个回放过程中观察到的最大 q）");
        lines.push("- tx：链路开始发送次数（tx_start；视为出队）");
        lines.push("- drop：丢包次数（drop；发生在该链路队列入队时）");
        const keys = Array.from(linkStats.keys()).sort();
        for (const k of keys) {
          const s = linkStats.get(k);
          if (!s) continue;
          const q = `${fmtBytes(s.q_bytes)}/${s.q_cap != null ? fmtCapBytes(s.q_cap) : "-"}`;
          const qp = `${fmtBytes(s.q_peak ?? 0)}/${s.q_cap != null ? fmtCapBytes(s.q_cap) : "-"}`;
          const lat = s.latency_ns != null ? fmtMs(s.latency_ns) : "-";
          const fd = s.first_drop_t != null ? fmtMs(s.first_drop_t) : "-";
          lines.push(
            `- ${k}: q=${q}, q_peak=${qp}, tx=${s.tx_pkts}, drop=${s.drop_pkts} (first_drop=${fd}), bw=${fmtGbps(s.bandwidth_bps)}, lat=${lat}`
          );
        }
        lines.push("");
        lines.push("TCP（全局事件计数）：");
        lines.push(`- send_data=${tcpStats.send_data}, send_ack=${tcpStats.send_ack}, recv_ack=${tcpStats.recv_ack}, rto=${tcpStats.rto}`);
        statsEl.textContent = lines.join("\n");
      }

      // ---------- TCP 时序图 ----------
      function redrawTcp() {
        tcpCtx.clearRect(0, 0, tcpCv.width, tcpCv.height);

        // 背景框
        rr(tcpCtx, 0.5, 0.5, tcpCv.width - 1, tcpCv.height - 1, 14);
        tcpCtx.fillStyle = "rgba(255,255,255,0.05)";
        tcpCtx.fill();
        tcpCtx.strokeStyle = "rgba(255,255,255,0.10)";
        tcpCtx.stroke();

        const conns = Array.from(tcpSeries.keys()).sort((a, b) => a - b);
        const prefer = filterFlowEl.value.trim() ? Number(filterFlowEl.value.trim()) : null;
        const pick = connPickEl.value;
        let cid = null;
        if (pick && pick !== "auto") {
          const pickN = Number(pick);
          if (tcpSeries.has(pickN)) cid = pickN;
        }
        if (cid == null && prefer != null && tcpSeries.has(prefer)) {
          cid = prefer;
        }
        if (cid == null) {
          cid = pickAutoConn(tcpSeries, curTime);
        }
        if (cid == null) {
          cid = conns[0];
        }
        if (cid == null) {
          drawTcpBox("cwnd 时序：无 tcp_* / dctcp_cwnd 事件");
          return;
        }
        const ser = tcpSeries.get(cid);
        const pts = ser?.points || [];
        const mss = ser?.mss || 1460;
        if (pts.length === 0) {
          drawTcpBox(`cwnd 时序：conn=${cid} 无可用数据点`);
          return;
        }

        const pad = { l: 70, r: 14, t: 22, b: 28 };
        const W = tcpCv.width - pad.l - pad.r;
        const H = tcpCv.height - pad.t - pad.b;
        const xOf = (t) => pad.l + ((t - t0) / Math.max(1, t1 - t0)) * W;

        const maxCwnd = Math.max(...pts.map((p) => p.cwnd));
        const maxPkts = Math.max(2, Math.ceil(maxCwnd / mss) + 2);
        const yOfPkts = (pkts) => pad.t + (1 - pkts / maxPkts) * H;

        // 网格 + y 轴标签
        tcpCtx.save();
        tcpCtx.strokeStyle = "rgba(255,255,255,0.10)";
        tcpCtx.fillStyle = "rgba(255,255,255,0.70)";
        tcpCtx.font = "11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, monospace";
        for (let k = 0; k <= 4; k++) {
          const pk = Math.round((maxPkts * k) / 4);
          const y = yOfPkts(pk);
          tcpCtx.beginPath();
          tcpCtx.moveTo(pad.l, y);
          tcpCtx.lineTo(pad.l + W, y);
          tcpCtx.stroke();
          tcpCtx.textAlign = "right";
          tcpCtx.textBaseline = "middle";
          tcpCtx.fillText(`${pk} pkts`, pad.l - 10, y);
        }
        tcpCtx.textAlign = "left";
        tcpCtx.textBaseline = "top";
        tcpCtx.fillText(`cwnd 时序（conn=${cid}，mss≈${mss}B）`, pad.l, 6);
        tcpCtx.restore();

        // 线条：cwnd / ssthresh / inflight
        drawTcpLine(pts, "ssthresh", "rgba(255,255,255,0.55)", true, xOf, yOfPkts, mss);
        drawTcpLine(pts, "inflight", "rgba(122,162,255,0.35)", false, xOf, yOfPkts, mss);
        drawTcpLine(pts, "cwnd", "#7aa2ff", false, xOf, yOfPkts, mss);

        // 当前点高亮 + 状态文本
        const curP = pickPointAt(pts, curTime);
        if (curP) {
          const x = xOf(curP.t);
          const y = yOfPkts(curP.cwnd / mss);
          tcpCtx.save();
          tcpCtx.fillStyle = "#ffdd57";
          tcpCtx.strokeStyle = "rgba(0,0,0,0.35)";
          tcpCtx.lineWidth = 2;
          tcpCtx.beginPath();
          tcpCtx.arc(x, y, 6, 0, Math.PI * 2);
          tcpCtx.fill();
          tcpCtx.stroke();
          tcpCtx.restore();

          const state = curP.state ?? "-";
          const lastAck = curP.lastAck ?? "-";
          const dup = curP.dup ?? "-";
          const alpha = curP.alpha != null ? `  alpha=${Number(curP.alpha).toFixed(3)}` : "";
          drawTcpBox(
            `state=${state}  cwnd=${fmtBytes(curP.cwnd)} (${(curP.cwnd / mss).toFixed(2)} pkts)  ssthresh=${fmtBytes(curP.ssthresh)}  inflight=${fmtBytes(curP.inflight)}  lastAck=${lastAck}  dupAck=${dup}${alpha}`
          );
        }
      }

      function drawTcpLine(pts, field, color, dashed, xOf, yOfPkts, mss) {
        tcpCtx.save();
        tcpCtx.strokeStyle = color;
        tcpCtx.lineWidth = 2;
        if (dashed) tcpCtx.setLineDash([6, 4]);
        tcpCtx.beginPath();
        let first = true;
        for (const p of pts) {
          const x = xOf(p.t);
          const y = yOfPkts(p[field] / mss);
          if (first) {
            tcpCtx.moveTo(x, y);
            first = false;
          } else {
            tcpCtx.lineTo(x, y);
          }
        }
        tcpCtx.stroke();
        tcpCtx.restore();
      }

      function drawTcpBox(text) {
        tcpCtx.save();
        tcpCtx.fillStyle = "rgba(0,0,0,0.45)";
        tcpCtx.strokeStyle = "rgba(255,255,255,0.12)";
        tcpCtx.lineWidth = 1;
        const x = 14;
        const y = tcpCv.height - 52;
        const w = tcpCv.width - 28;
        const h = 38;
        rr(tcpCtx, x, y, w, h, 10);
        tcpCtx.fill();
        tcpCtx.stroke();
        tcpCtx.fillStyle = "rgba(255,255,255,0.90)";
        tcpCtx.font = "11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, monospace";
        tcpCtx.textAlign = "left";
        tcpCtx.textBaseline = "middle";
        tcpCtx.fillText(text, x + 10, y + h / 2);
        tcpCtx.restore();
      }

      function pickPointAt(pts, t) {
        let lo = 0,
          hi = pts.length - 1,
          ans = null;
        while (lo <= hi) {
          const mid = (lo + hi) >> 1;
          if (pts[mid].t <= t) {
            ans = pts[mid];
            lo = mid + 1;
          } else {
            hi = mid - 1;
          }
        }
        return ans;
      }

      function pickAutoConn(series, t) {
        let bestCid = null;
        let bestPast = -Infinity;
        let bestFuture = Infinity;
        for (const [cid, ser] of series.entries()) {
          const pts = ser?.points || [];
          if (pts.length === 0) continue;
          const last = pickPointAt(pts, t);
          if (last) {
            const ts = Number(last.t ?? 0);
            if (ts >= bestPast) {
              bestPast = ts;
              bestCid = cid;
            }
          } else if (bestPast === -Infinity) {
            const first = Number(pts[0].t ?? 0);
            if (first < bestFuture) {
              bestFuture = first;
              bestCid = cid;
            }
          }
        }
        return bestCid;
      }

      function buildTcpSeries(evts) {
        /** @type {Map<number, any[]>} */
        const byConn = new Map();
        for (const e of evts) {
          if (!e || typeof e.kind !== "string") continue;
          if (!e.kind.startsWith("tcp_") && e.kind !== "dctcp_cwnd") continue;
          const cid = Number(e.conn_id ?? e.flow_id ?? 0);
          if (!cid) continue;
          if (!byConn.has(cid)) byConn.set(cid, []);
          byConn.get(cid).push(e);
        }
        const out = new Map();
        for (const [cid, arr] of byConn.entries()) {
          arr.sort((a, b) => (a.t_ns ?? 0) - (b.t_ns ?? 0));
          const mss = inferMss(arr) || 1460;
          const cwndSamples = arr.filter((e) => e.kind === "dctcp_cwnd");
          if (cwndSamples.length) {
            const pts = cwndSamples.map((e) => ({
              t: Number(e.t_ns ?? 0),
              cwnd: Number(e.cwnd_bytes ?? 0),
              ssthresh: Number(e.ssthresh_bytes ?? 0),
              inflight: Number(e.inflight_bytes ?? 0),
              alpha: e.alpha != null ? Number(e.alpha) : null,
              lastAck: null,
              dup: null,
              state: "DCTCP",
              reason: "sample",
            }));
            out.set(cid, { mss, points: pts });
            continue;
          }
          const initCwnd = inferInitCwnd(arr, mss);
          let cwnd = initCwnd;
          let ssthresh = 1000 * mss;
          let lastAck = 0;
          let dup = 0;
          let state = "SS";
          /** @type {Map<number, number>} */
          const infl = new Map(); // seq -> len
          const pts = [];

          const inflightBytes = () => {
            let s = 0;
            for (const v of infl.values()) s += v;
            return s;
          };
          const rec = (t, reason) =>
            pts.push({ t, cwnd, ssthresh, inflight: inflightBytes(), lastAck, dup, state, reason });

          rec(Number(arr[0]?.t_ns ?? 0), "init");

          for (const e of arr) {
            const t = Number(e.t_ns ?? 0);
            if (e.kind === "tcp_send_data") {
              if (e.seq != null && e.len != null) infl.set(Number(e.seq), Number(e.len));
              rec(t, "send_data");
            } else if (e.kind === "tcp_recv_ack") {
              const ack = Number(e.ack ?? 0);
              if (ack > lastAck) {
                dup = 0;
                const newly = ack - lastAck;
                lastAck = ack;
                for (const [seq, len] of Array.from(infl.entries())) {
                  if (seq + len <= ack) infl.delete(seq);
                }
                if (cwnd < ssthresh) {
                  state = "SS";
                  cwnd = cwnd + newly;
                } else {
                  state = "CA";
                  const inc = Math.max(1, Math.floor((mss * mss) / Math.max(1, cwnd)));
                  cwnd = cwnd + inc;
                }
                rec(t, "new_ack");
              } else if (ack === lastAck) {
                dup = dup + 1;
                if (dup === 3) {
                  state = "FR";
                  ssthresh = Math.max(Math.floor(cwnd / 2), 2 * mss);
                  cwnd = ssthresh + 3 * mss;
                  rec(t, "3_dupack");
                } else if (dup > 3) {
                  state = "FR";
                  cwnd = cwnd + mss;
                  rec(t, "more_dupack");
                } else {
                  rec(t, "dupack");
                }
              }
            } else if (e.kind === "tcp_rto") {
              state = "RTO";
              ssthresh = Math.max(Math.floor(cwnd / 2), 2 * mss);
              cwnd = mss;
              dup = 0;
              rec(t, "rto");
            } else if (e.kind === "tcp_send_ack") {
              rec(t, "send_ack");
            }
          }
          out.set(cid, { mss, points: pts });
        }
        return out;
      }

      function inferMss(arr) {
        let m = 0;
        for (const e of arr) {
          if (e.kind === "tcp_send_data" && e.len != null) m = Math.max(m, Number(e.len));
        }
        return m || null;
      }

      function inferInitCwnd(arr, mss) {
        const ds = arr.filter((e) => e.kind === "tcp_send_data" && e.t_ns != null && e.len != null);
        if (ds.length === 0) return 10 * mss;
        const tMin = Math.min(...ds.map((e) => Number(e.t_ns)));
        const sum = ds.filter((e) => Number(e.t_ns) === tMin).reduce((s, e) => s + Number(e.len), 0);
        return Math.max(mss, sum || 10 * mss);
      }

      // round-rect helper（兼容）
      function rr(c, x, y, w, h, r) {
        if (typeof c.roundRect === "function") {
          c.beginPath();
          c.roundRect(x, y, w, h, r);
          return;
        }
        const rr = Math.min(r, w / 2, h / 2);
        c.beginPath();
        c.moveTo(x + rr, y);
        c.arcTo(x + w, y, x + w, y + h, rr);
        c.arcTo(x + w, y + h, x, y + h, rr);
        c.arcTo(x, y + h, x, y, rr);
        c.arcTo(x, y, x + w, y, rr);
        c.closePath();
      }

      function stepOnce() {
        if (filtered.length === 0) return;
        // advance to next event time
        const ev = filtered[cursor];
        if (!ev) return;
        setTime(ev.t_ns);
        // apply all events at exactly this t_ns
        applyUntil(ev.t_ns);
        redraw();
        updateStatus();
        showCurrentText();
        showStatsText();
        redrawTcp();
      }

      function setTime(t) {
        curTime = Math.max(t0, Math.min(t1, t));
        const p = (curTime - t0) / Math.max(1, t1 - t0);
        sliderEl.value = String(Math.floor(p * 1000));
      }

      function applyUntil(t) {
        // if time goes backward, recompute from scratch
        if (filtered.length === 0) return;
        if (cursor > 0 && cursor < filtered.length && filtered[cursor - 1].t_ns > t) {
          inflight = new Map();
          nodeHighlight = new Map();
          dropMarks = [];
          lastEventsText = [];
          nodeStats = new Map();
          linkStats = new Map();
          tcpStats = { send_data: 0, send_ack: 0, recv_ack: 0, rto: 0 };
          initStatsFromMeta();
          cursor = 0;
        }
        while (cursor < filtered.length && filtered[cursor].t_ns <= t) {
          const ev = filtered[cursor++];
          applyEvent(ev);
        }
      }

      function applyEvent(ev) {
        const kind = ev.kind;
        // concise text line
        const head = `[${fmtMs(ev.t_ns)}] ${kind}`;
        if (kind === "tx_start" && ev.pkt_id != null) {
          inflight.set(Number(ev.pkt_id), {
            pkt_id: Number(ev.pkt_id),
            flow_id: ev.flow_id != null ? Number(ev.flow_id) : null,
            from: Number(ev.link_from),
            to: Number(ev.link_to),
            depart: Number(ev.depart_ns),
            arrive: Number(ev.arrive_ns),
            pkt_kind: ev.pkt_kind || "other",
          });
          lastEventsText.push(
            `${head} pkt=${ev.pkt_id} ${ev.link_from}->${ev.link_to} depart=${fmtMs(ev.depart_ns)} arrive=${fmtMs(ev.arrive_ns)}`
          );
          // link stats: dequeue at tx_start
          const lk = linkKey(Number(ev.link_from), Number(ev.link_to));
          const ls =
            linkStats.get(lk) || { q_bytes: 0, q_peak: 0, q_cap: null, tx_pkts: 0, drop_pkts: 0, first_drop_t: null };
          const pb = ev.pkt_bytes != null ? Number(ev.pkt_bytes) : 0;
          ls.q_bytes = Math.max(0, Number(ls.q_bytes || 0) - pb);
          ls.tx_pkts = Number(ls.tx_pkts || 0) + 1;
          ls.q_peak = Math.max(Number(ls.q_peak || 0), Number(ls.q_bytes || 0));
          linkStats.set(lk, ls);
        } else if (kind === "delivered" && ev.pkt_id != null) {
          inflight.delete(Number(ev.pkt_id));
          lastEventsText.push(`${head} pkt=${ev.pkt_id} node=${ev.node}`);
          const ns = nodeStats.get(Number(ev.node)) || {};
          ns.delivered = Number(ns.delivered || 0) + 1;
          nodeStats.set(Number(ev.node), ns);
        } else if (kind === "drop" && ev.pkt_id != null) {
          // 丢包不应该“直接消失”而看不见：在链路中点放一个短暂的红色 X 标记
          inflight.delete(Number(ev.pkt_id));
          dropMarks.push({
            pkt_id: Number(ev.pkt_id),
            flow_id: ev.flow_id != null ? Number(ev.flow_id) : null,
            from: Number(ev.link_from),
            to: Number(ev.link_to),
            at: Number(ev.t_ns),
            until: Number(ev.t_ns) + 2_000_000, // 2ms
          });
          lastEventsText.push(
            `${head} pkt=${ev.pkt_id} link=${ev.link_from}->${ev.link_to} q=${ev.q_bytes}/${ev.q_cap_bytes}`
          );
          const lk = linkKey(Number(ev.link_from), Number(ev.link_to));
          const ls =
            linkStats.get(lk) || { q_bytes: 0, q_peak: 0, q_cap: null, tx_pkts: 0, drop_pkts: 0, first_drop_t: null };
          ls.drop_pkts = Number(ls.drop_pkts || 0) + 1;
          // q_bytes/q_cap_bytes 直接覆盖（来自真实队列状态）
          if (ev.q_bytes != null) ls.q_bytes = Number(ev.q_bytes);
          if (ev.q_cap_bytes != null) ls.q_cap = Number(ev.q_cap_bytes);
          ls.q_peak = Math.max(Number(ls.q_peak || 0), Number(ls.q_bytes || 0));
          if (ls.first_drop_t == null) ls.first_drop_t = Number(ev.t_ns ?? 0);
          linkStats.set(lk, ls);
        } else if (kind === "node_rx") {
          nodeHighlight.set(Number(ev.node), { node: Number(ev.node), until: ev.t_ns + 200_000 /* 0.2ms */ });
          lastEventsText.push(`${head} node=${ev.node} (${ev.node_kind}:${ev.node_name}) pkt=${ev.pkt_id}`);
          const ns = nodeStats.get(Number(ev.node)) || {};
          ns.rx = Number(ns.rx || 0) + 1;
          if (ev.pkt_bytes != null) ns.bytes = Number(ns.bytes || 0) + Number(ev.pkt_bytes);
          nodeStats.set(Number(ev.node), ns);
        } else if (kind === "node_forward") {
          lastEventsText.push(`${head} node=${ev.node} -> next=${ev.next} pkt=${ev.pkt_id}`);
          const ns = nodeStats.get(Number(ev.node)) || {};
          ns.forward = Number(ns.forward || 0) + 1;
          nodeStats.set(Number(ev.node), ns);
        } else if (kind === "enqueue") {
          lastEventsText.push(`${head} pkt=${ev.pkt_id} link=${ev.link_from}->${ev.link_to} q=${ev.q_bytes}/${ev.q_cap_bytes}`);
          const lk = linkKey(Number(ev.link_from), Number(ev.link_to));
          const ls =
            linkStats.get(lk) || { q_bytes: 0, q_peak: 0, q_cap: null, tx_pkts: 0, drop_pkts: 0, first_drop_t: null };
          // 用事件里的 q_bytes/q_cap_bytes（最准确）
          if (ev.q_bytes != null) ls.q_bytes = Number(ev.q_bytes);
          if (ev.q_cap_bytes != null) ls.q_cap = Number(ev.q_cap_bytes);
          ls.q_peak = Math.max(Number(ls.q_peak || 0), Number(ls.q_bytes || 0));
          linkStats.set(lk, ls);
        } else if (kind === "dctcp_cwnd") {
          // cwnd 采样事件仅用于时序图展示
        } else if (kind.startsWith("tcp_")) {
          // tcp_send_data / tcp_send_ack / tcp_recv_ack / tcp_rto
          const extra = [];
          if (ev.conn_id != null) extra.push(`conn=${ev.conn_id}`);
          if (ev.seq != null) extra.push(`seq=${ev.seq}`);
          if (ev.len != null) extra.push(`len=${ev.len}`);
          if (ev.ack != null) extra.push(`ack=${ev.ack}`);
          lastEventsText.push(`${head} ${extra.join(" ")}`.trim());
          const cid = ev.conn_id != null ? Number(ev.conn_id) : null;
          if (cid != null) {
            // dumbbell 下 conn_id == flow_id == src 节点的统计并不总能直接映射到 node，
            // 这里先用 flow_id 过滤；节点侧统计我们只记录“看到的包”，TCP 事件按全局计数展示。
            // 若将来 meta 里加 conn->src/dst mapping，可再细化。
          }
        } else {
          lastEventsText.push(`${head} pkt=${ev.pkt_id ?? "-"}`);
        }

        // TCP 事件计数（全局）
        if (kind === "tcp_send_data") {
          tcpStats.send_data += 1;
        } else if (kind === "tcp_send_ack") {
          tcpStats.send_ack += 1;
        } else if (kind === "tcp_recv_ack") {
          tcpStats.recv_ack += 1;
        } else if (kind === "tcp_rto") {
          tcpStats.rto += 1;
        }
      }

      function redraw() {
        ctx.clearRect(0, 0, cv.width, cv.height);

        // links
        for (const l of drawLinks) {
          drawLink(nodeById.get(l.from), nodeById.get(l.to));
        }

        // nodes
        for (const n of nodes) drawNode(n);

        // packets in flight
        for (const p of inflight.values()) {
          drawPacket(p);
        }

        // drop marks (red X)
        dropMarks = dropMarks.filter((m) => m.until >= curTime);
        // 为了避免文字叠在一起：
        // - X 永远画
        // - 文字标签只给“每条链路最近的 1 个 drop”画（其余不画文字）
        /** @type {Map<string, Array<any>>} */
        const perLink = new Map();
        for (const m of dropMarks) {
          const k = linkKey(m.from, m.to);
          if (!perLink.has(k)) perLink.set(k, []);
          perLink.get(k).push(m);
        }
        for (const [k, arr] of perLink.entries()) {
          // 最近的在前
          arr.sort((a, b) => b.at - a.at);
          for (let i = 0; i < arr.length; i++) {
            drawDropMark(arr[i], i, i === 0);
          }
        }
      }

      function drawLink(a, b) {
        if (!a || !b) return;
        ctx.save();
        ctx.strokeStyle = "rgba(255,255,255,0.18)";
        ctx.lineWidth = 6;
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();

        ctx.strokeStyle = "rgba(0,0,0,0.25)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
        ctx.restore();
      }

      function drawNode(n) {
        const hl = nodeHighlight.get(n.id);
        const isHl = hl && hl.until >= curTime;
        const r = (n.kind === "switch" ? 26 : 22) * nodeScale;
        const fontSize = Math.max(8, Math.round(12 * nodeScale));
        ctx.save();
        ctx.fillStyle = isHl ? "rgba(122,162,255,0.35)" : "rgba(255,255,255,0.10)";
        ctx.strokeStyle = isHl ? "rgba(122,162,255,0.85)" : "rgba(255,255,255,0.22)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(n.x, n.y, r, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = "#e7ecff";
        ctx.font = `${fontSize}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, monospace`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(n.name, n.x, n.y);
        ctx.restore();
      }

      function lerp(a, b, t) {
        return a + (b - a) * t;
      }

      function pktColor(kind) {
        if (kind === "data") return "#7aa2ff";
        if (kind === "ack") return "#64d49a";
        return "#cdd6ff";
      }

      function drawDropMark(m, stackIdx, showLabel) {
        const a = nodeById.get(m.from);
        const b = nodeById.get(m.to);
        if (!a || !b) return;
        // 基础位置：链路中点；再按垂直方向堆叠偏移，避免重叠
        const mx = (a.x + b.x) / 2;
        const my = (a.y + b.y) / 2;
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        const len = Math.max(1, Math.hypot(dx, dy));
        const nx = -dy / len;
        const ny = dx / len;
        const layer = stackIdx % 6; // 最多 6 层循环
        const offset = (layer - 2.5) * 14;
        const x = mx + nx * offset;
        const y = my + ny * offset;

        // 按时间淡出
        const alpha = Math.max(0, Math.min(1, 1 - (curTime - m.at) / Math.max(1, m.until - m.at)));

        ctx.save();
        ctx.globalAlpha = 0.25 + 0.75 * alpha;
        ctx.strokeStyle = "#ff6b6b";
        ctx.lineWidth = 3;
        ctx.lineCap = "round";
        const r = 10;
        ctx.beginPath();
        ctx.moveTo(x - r, y - r);
        ctx.lineTo(x + r, y + r);
        ctx.moveTo(x - r, y + r);
        ctx.lineTo(x + r, y - r);
        ctx.stroke();

        // 标签只展示每条链路最近的 1 个 drop，避免大量 drop 时文字叠在一起
        if (showLabel) {
          const label = `drop ${m.from}->${m.to} pkt=${m.pkt_id}`;
          ctx.font = "11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, monospace";
          const tw = ctx.measureText(label).width;
          const pad = 6;
          const bx = x - (tw / 2) - pad;
          const by = y + r + 2;
          const bw = tw + pad * 2;
          const bh = 18;
          ctx.fillStyle = "rgba(0,0,0,0.55)";
          ctx.strokeStyle = "rgba(255,255,255,0.12)";
          ctx.lineWidth = 1;
          rr(ctx, bx, by, bw, bh, 8);
          ctx.fill();
          ctx.stroke();
          ctx.fillStyle = "rgba(255,255,255,0.90)";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(label, x, by + bh / 2);
        }
        ctx.restore();
      }

      function drawPacket(p) {
        const a = nodeById.get(p.from);
        const b = nodeById.get(p.to);
        if (!a || !b) return;

        const t = (() => {
          if (curTime <= p.depart) return 0;
          if (curTime >= p.arrive) return 1;
          return (curTime - p.depart) / Math.max(1, p.arrive - p.depart);
        })();
        const x = lerp(a.x, b.x, t);
        const y = lerp(a.y, b.y, t);

        ctx.save();
        ctx.fillStyle = pktColor(p.pkt_kind);
        ctx.strokeStyle = "rgba(0,0,0,0.35)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(x, y, Math.max(3, 7 * nodeScale), 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        ctx.restore();
      }

      function tick(ts) {
        requestAnimationFrame(tick);
        if (!playing || filtered.length === 0) return;
        if (!lastWall) lastWall = ts;
        const dt = ts - lastWall;
        lastWall = ts;

        const speed = Number(speedEl.value || "1");
        // 关键修复：不要用 wall-ms 直接映射 sim-ms（仿真通常只有几十 ms，会“一两帧跑完”）
        // 改为：默认用 targetWallSec 在 1x 速度下播完整段仿真。
        const targetWallMs = Number(targetWallSecEl.value || "12") * 1000;
        const simDur = Math.max(1, t1 - t0);
        const advance = (dt * (simDur / targetWallMs)) * speed;
        const target = Math.min(t1, curTime + advance);
        setTime(target);
        applyUntil(curTime);
        redraw();
        updateStatus();
        showCurrentText();
        showStatsText();
        redrawTcp();

        if (curTime >= t1) {
          playing = false;
        }
      }

      requestAnimationFrame(tick);

      fileEl.addEventListener("change", async () => {
        const f = fileEl.files?.[0];
        if (!f) return;
        const text = await f.text();
        try {
          const arr = JSON.parse(text);
          if (!Array.isArray(arr)) throw new Error("JSON 顶层不是数组");
          // 支持 meta：数组里可以包含 kind=meta（建议 t=0 第一个）
          const raw = arr;
          const metas = raw.filter((e) => e && e.kind === "meta");
          meta = metas.length ? metas[0] : null;
          events = raw.filter((e) => e && e.kind !== "meta");
          // sort just in case
          events.sort((a, b) => (a.t_ns ?? 0) - (b.t_ns ?? 0));
          t0 = events.length ? events[0].t_ns : 0;
          t1 = events.length ? events[events.length - 1].t_ns : 0;
          filtered = events;
          // 用 meta 里的节点信息（若存在）重建画布节点
          if (meta?.nodes && Array.isArray(meta.nodes)) {
            const list = meta.nodes.slice().sort((a, b) => a.id - b.id);
            const fat = layoutFatTree(list);
            const layout = fat ?? layoutCircle(list);
            nodes = layout.nodes;
            nodeScale = layout.scale;
            nodeById = new Map(nodes.map((n) => [n.id, n]));
          } else {
            nodes = defaultNodes.map((n) => ({ ...n }));
            nodeScale = 1;
            nodeById = new Map(nodes.map((n) => [n.id, n]));
          }
          const pairs = buildLinkPairs(meta?.links);
          drawLinks = pairs.length ? pairs : defaultLinks.slice();
          setEnabled(true);
          playing = false;
          lastWall = 0;
          resetPlayback();
        } catch (e) {
          setEnabled(false);
          statusEl.textContent = "解析失败：" + String(e);
        }
      });

      function jumpToNextDrop() {
        if (filtered.length === 0) return;
        const flow = filterFlowEl.value.trim();
        const flowN = flow === "" ? null : Number(flow);
        const idx = filtered.findIndex(
          (e) =>
            e &&
            e.kind === "drop" &&
            (e.t_ns ?? 0) > curTime &&
            (flowN == null || Number(e.flow_id) === flowN)
        );
        if (idx < 0) return;
        playing = false;
        const t = filtered[idx].t_ns ?? t0;
        setTime(t);
        // 强制从头重放到该时刻，确保 stats 与动画一致
        inflight = new Map();
        nodeHighlight = new Map();
        dropMarks = [];
        lastEventsText = [];
        nodeStats = new Map();
        linkStats = new Map();
        tcpStats = { send_data: 0, send_ack: 0, recv_ack: 0, rto: 0 };
        tcpSeries = buildTcpSeries(events);
        updateConnPick();
        initStatsFromMeta();
        cursor = 0;
        applyUntil(curTime);
        redraw();
        updateStatus();
        showCurrentText();
        showStatsText();
        redrawTcp();
      }

      jumpDropEl.addEventListener("click", jumpToNextDrop);

      connPickEl.addEventListener("change", () => {
        redrawTcp();
      });

      filterFlowEl.addEventListener("input", applyFilter);
      filterPktEl.addEventListener("input", applyFilter);
      targetWallSecEl.addEventListener("change", () => {
        updateStatus();
      });

      playEl.addEventListener("click", () => {
        if (filtered.length === 0) return;
        playing = true;
        lastWall = 0;
      });
      pauseEl.addEventListener("click", () => {
        playing = false;
      });
      stepEl.addEventListener("click", () => {
        playing = false;
        stepOnce();
      });

      sliderEl.addEventListener("input", () => {
        if (filtered.length === 0) return;
        playing = false;
        const p = Number(sliderEl.value) / 1000;
        const t = t0 + (t1 - t0) * p;
        setTime(t);
        applyUntil(curTime);
        redraw();
        updateStatus();
        showCurrentText();
        showStatsText();
        redrawTcp();
      });

      window.addEventListener("keydown", (e) => {
        if (e.key === " ") {
          e.preventDefault();
          playing = !playing;
          lastWall = 0;
        } else if (e.key === "ArrowRight") {
          e.preventDefault();
          playing = false;
          stepOnce();
        } else if (e.key === "ArrowLeft") {
          e.preventDefault();
          playing = false;
          // coarse step back: go to previous event time (recompute)
          if (filtered.length === 0) return;
          const idx = Math.max(0, cursor - 2);
          const t = filtered[idx]?.t_ns ?? t0;
          setTime(t);
          // force recompute from scratch
          inflight = new Map();
          nodeHighlight = new Map();
          dropMarks = [];
          lastEventsText = [];
          nodeStats = new Map();
          linkStats = new Map();
          tcpStats = { send_data: 0, send_ack: 0, recv_ack: 0, rto: 0 };
          initStatsFromMeta();
          cursor = 0;
          applyUntil(curTime);
          redraw();
          updateStatus();
          showCurrentText();
          showStatsText();
          redrawTcp();
        }
      });
    </script>
  </body>
</html>
